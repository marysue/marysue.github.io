I"/(<p>One might imagine that this count sentences assignment was about using self (the “this” equivalent in non-scripting languages).  However, it was not.  The bulk of my time was working through regular expressions.</p>

<p>The author of the lab suggested using the split string function.  But split requires a regular expression, unless you’re simply splitting on one specific character.  In this assignment we’re splitting on three:  ? . !</p>

<p>I have an excellent resource for regular expression testing: <a href="https://regexr.com/">RegExp Console</a>  This is crucial in this assignment.  You’ll drive yourself nuts trying to compile over and over until you get your regexp correct.</p>

<p>In this tool you’re able to test out the regular expression on any string you place in the window.  Further, it tells you what each element of your regular expression represents as you hover over the regexp characters.</p>

<p>In this assignment we needed to count the number of sentences in a given string, taking into consideration that some sentences may end with multiple punctuations, such as “???”, “!!!” or “…”</p>

<p>I will spare you the tutorial on regular expressions, and simply layout the regexp I created and explain what each step in constructing this expression was about:</p>

<table>
  <tbody>
    <tr>
      <td>The full expression:   (/(!+)\s</td>
      <td>(.+)\s</td>
      <td>(\?+)\s/)</td>
    </tr>
  </tbody>
</table>

<p>This expression states to record matches on each of the following:
    – any string that contained one or more “!”’s
		– any string that contained one or more “.”’s
		– any string that contained one or more “?”’s</p>

<h3 id="the-construction-of-the-regular-expression-is-as-follows">The construction of the regular expression is as follows:</h3>

<p><code class="language-plaintext highlighter-rouge">(//)</code>        :        regular expression placed between the ‘/’</p>

<p><code class="language-plaintext highlighter-rouge">(!+) </code>      :        matches one or more exclamation points - marks as one match.   Eliminate the + if you want to match on everysingle ! … but we don’t as some sentences end in !!!</p>

<p><code class="language-plaintext highlighter-rouge">\s</code>         :        matches any whitespace character
                           so <code class="language-plaintext highlighter-rouge">(!+)\s</code> matches one or more exclamation points followed by any number of 
													 whitespace character so “This is a blast!     “   would count as one match</p>

<p><code class="language-plaintext highlighter-rouge">|</code>            :       OR … match the previous expression OR the next expression</p>

<p><code class="language-plaintext highlighter-rouge">(\.+)</code>     :       use care here, the period means “all or any” so you need to quote the
period to match only the character - not interpret the meaning.  So this expression matches one or more periods</p>

<p><code class="language-plaintext highlighter-rouge">\s </code>       :       see above</p>

<p><code class="language-plaintext highlighter-rouge"> (\?+) </code> :       again use care, the<code class="language-plaintext highlighter-rouge"> ?</code> means to match between 0 and 1 of the previous
character – so we need to quote this to match on the character and not interpret the meaning</p>

<p><code class="language-plaintext highlighter-rouge">\s</code>        :        see above</p>

<p>Splitting a string on the simple ?.! characters will yield multiple strings with only a “?” in it.</p>

<p>So for a given sentence:</p>

<p><code class="language-plaintext highlighter-rouge">"This, well, is a sentence. This is too!! And so is this, I think? Woo...".split(/[\?\.\!]/)</code></p>

<p>Returns the 5 element array:</p>

<p><code class="language-plaintext highlighter-rouge">["This, well, is a sentence", " This is too", "", " And so is this, I think", " Woo"]</code></p>

<p>We cannot simply count the elements in this array, as it has empty elements.  Our count would be off.</p>

<p>There are a couple of ways to manage this.</p>

<h3 id="split-reject">Split, Reject</h3>

<p>You can parse the array using “reject”, which returns a new array with only elements in the reject block which were false.</p>

<p>So for example, with the array <code class="language-plaintext highlighter-rouge">["a", "b", "c", "d"].reject{|x| x=="c"}</code> will return false for a, b, and d.  Your resulting array will be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	 ["a", "b", "d"]
</code></pre></div></div>

<p>In our case we can use reject to remove the empty string.</p>

<p>Our code then becomes the following three lines:</p>
<ul>
<li>split the string into an array of sentences, including nil sentences</li>
<li>reject the members of the array which are nil, returning an array of non-nil sentences</li>
<li>use this array's length method to count the elements in the array</li>
</ul>

<h3 id="gsub-split">gsub, split</h3>

<p>You can use gsub to substitute the matching characters, placing a unique character in its place.  gsub will return a string.  Once you have a string with unique characters you can split on that character, and split will return an array which you then can get a proper count for the number of sentences:</p>

<p><code class="language-plaintext highlighter-rouge">sentence = "This, well, is a sentence. This is too!! And so is this, I think? Woo..."</code><br />
<code class="language-plaintext highlighter-rouge">newSentence = sentence.gsub(/(!+)\s|(\.+)\s|(\?+)\s/, '\0|')</code></p>

<p>Your newSentence is now a string:<br /></p>

<table>
  <tbody>
    <tr>
      <td>` “This, well, is a sentence.</td>
      <td>This is too!!</td>
      <td>And so is this, I think?</td>
      <td>Woo…”`</td>
    </tr>
  </tbody>
</table>

<p>And you can easily split this now, on the pipe character:</p>

<p><code class="language-plaintext highlighter-rouge">newArr =  newSentence.split("|");</code></p>

<p>Which returns the array:</p>

<p><code class="language-plaintext highlighter-rouge">["This, well, is a sentence. ", "This is too!! ", "And so is this, I think? ", "Woo..."]</code></p>

<p>And now you can count the members of this array</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> `newArr.length  =&gt;  4`
</code></pre></div></div>

<h3 id="lesson-in-complexity">Lesson in complexity</h3>

<p>Finally, I found this on the web.  Now that you understand the reject function – which is, in itself a map function, you could chain map and reject functions.</p>

<p>WARNING:  This is a truth and beauty issue.  Some developers believe if they can make code work in less lines that it is better.  I counter that argument with – is it understandable?  Is it easier for someone who did not write the code to understand what you’ve written?  If the answer is no!  I’d suggest breaking your code into smaller, more easily digestable chunks.  The following code is a perfect example of this.</p>

<p>First, the actual line of code I found:</p>

<p><code class="language-plaintext highlighter-rouge">sentence.split(/[.!?]/).map{|x| !(x.match(/\w+/).nil?)}.reject{|x| x == false}.size </code></p>

<p>WTF?</p>

<p>The overview of this function, which is pretty brain warping, is:</p>
<ul>
<li>Take all the elements of the array and run them through map, </li>
<li>In the map function, create an array that answers the question:  Is this an empty string.  The result from this map is an array of booleans representing whether the string is a sentence.</li>
<li>Take this array of booleans, and remove the element of the array that is false (or IS an empty string).  The result from this "reject" function returns an array of booleans which should all be true:  they ARE all strings.</li>
<li>Take this array and count the members.  This should yield the number of sentences found in the string. </li>
</ul>

<p>You could do this by taking multiple steps:</p>

<p><code class="language-plaintext highlighter-rouge">sentence = "This, well, is a sentence. This is too!! And so is this, I think? Woo..."</code></p>

<p><code class="language-plaintext highlighter-rouge">step1Arr=sentence.split(/[\?\.\!]/);</code></p>

<p>This returns a new array of sentences but some sentences may be blank:</p>

<p><code class="language-plaintext highlighter-rouge">["This, well, is a sentence", " This is too", "", " And so is this, I think", " Woo"]</code></p>

<p><code class="language-plaintext highlighter-rouge">step2Arr = step1Arr.map(!(x.match(/\w+/))}</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`[#&lt;MatchData "This"&gt;, #&lt;MatchData "This"&gt;, nil, #&lt;MatchData "And"&gt;, #&lt;MatchData "Woo"&gt;]]`
</code></pre></div></div>

<p>Now cycle through every element of intermedArr and determine whether it is nil, or there is a word:</p>

<p><code class="language-plaintext highlighter-rouge">step3Arr = step2Arr.map{|x| x.nil?}</code></p>

<p>which returns:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`[false, false, true, false, false]`
</code></pre></div></div>

<p>make this more intuitive - because each of the false’s were acutally true - they were a sentence:</p>

<p><code class="language-plaintext highlighter-rouge">step4Arr = step3Arr.map{|x| !x}</code></p>

<p>returns:</p>

<p><code class="language-plaintext highlighter-rouge">[true, true, false, true, true]</code></p>

<p>Filter out these results to contain only booleans representing sentences:</p>

<p><code class="language-plaintext highlighter-rouge">finalArr = step4Arr.map{|x| x==false}</code></p>

<p>returns:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`[true, true, true, true]`
</code></pre></div></div>

<p>Now count your final array to yield the number of sentences:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`finalArr.length  ==&gt; returns 4`
</code></pre></div></div>
:ET